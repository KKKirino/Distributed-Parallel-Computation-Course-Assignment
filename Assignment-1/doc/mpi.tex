\documentclass[11pt]{article}
  \usepackage{pgfplots}
  \pgfplotsset{compat=1.5.1} % 用来保证双 y 轴时两个 y 轴的 label 正确显示

  \input{../../.template/structure.tex} % Include the file specifying the document structure and custom commands

  % 如果提示没有字体，请修改此处的字体路径为当前编译文件的相对路径
  \setmainfont[ExternalLocation=../../.template/]{STZHONGS.ttf}

  % 用于在代码内显示中文
  \usepackage{xeCJK}
  \setCJKmonofont[ExternalLocation=../../.template/]{STZHONGS.ttf}
  
  %----------------------------------------------------------------------------------------
  %	ASSIGNMENT INFORMATION
  %----------------------------------------------------------------------------------------
  
  \title{\Large 分布式并行计算课程作业 \#1 \\
  \LARGE 埃拉托斯特尼素数筛选算法并行及性能优化} % Title of the assignment
  
  \author{杨睿妮 \texttt{(2018011205014)} \\ \url{yangruinii@foxmail.com}} % Author name and email address
  
  \date{电子科技大学 --- \today} % University, school and/or department name(s) and a date
  
  %----------------------------------------------------------------------------------------
  
  \begin{document}
  
  \maketitle % Print the title

  \section{实验说明}
  \begin{itemize}
    \item 使用 MPI 编程实现埃拉托斯特尼筛法并行算法。
    \item 对程序进行性能分析以及调优
  \end{itemize}

  \section{实验环境}
  实验环境如表 \ref{tab:env} 所示。
  \begin{table}[htbp]
    \centering
    \caption{实验环境配置表}
    \label{tab:env}
    \begin{tabular}{ll}
      \hline
      处理器 & lntel(R) Core(TM) i5-8300H CPU @2.30GHz \\
      \hline
      内存 & 16GB \\
      \hline
      MPI 库 & Open MPI 2.1.1\\
      \hline
      操作系统 & Ubuntu 18.04 LTS \\
      \hline
    \end{tabular}
  \end{table}
  
  其中 Open MPI 环境使用如下命令配置：
  \begin{commandline}
    \begin{verbatim}
$ sudo apt install openmpi-bin openmpi-common openmpi-doc libopenmpi-dev
    \end{verbatim}
\end{commandline}

并使用以下命令编译和运行基准代码，以使用四线程求解 1000 以内的素数个数为例：
\begin{commandline}
  \begin{verbatim}
$ echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope # 关闭报错显示
$ mpic++ baseline.c -o baseline.o
$ mpirun -np 4 ./baseline.o 1000
  \end{verbatim}
\end{commandline}

  \section{程序说明}
  \subsection{基准代码 Bug 修改}
  首先我们编译基准代码，以试运行求解 $10^9$ 以内的素数个数。发现在单线程下，可以正常求解 $10^9$ 以内素数个数，但是在多线程的情况下，只能够求解 $10^8$ 以内的素数个数，在求解 $10^9$及以上的规模时，程序输出 \lstinline{Cannot allocate enough memory}，查看基准代码后，发现在分配 \verb|marked| 数组时出现内存申请错误。

  进一步定位错误，发现 \verb|size| 变量存在溢出问题。解决方法为修改与 \verb|size| 相关的变量为 \verb|long| 类型。 修改后的相关源码如下：
  \begin{file}[baseline.cpp]
    \begin{lstlisting}[language=C++]
// ...
long count = 0;
long global_count = 0; // 正确初始化两个 count 变量
long high_value; 
long low_value;
long size;
long proc0_size;
// ...
proc0_size = (n - 1) / p;
low_value = 2 + id * proc0_size;
high_value = 1 + (id + 1) * proc0_size;
size = high_value - low_value + 1;
// ...
    \end{lstlisting}
  \end{file}

  至此基准代码可以正常求解 $10^9$ 级别素数的个数问题。

  \subsection{基准代码性能分析}
  \begin{figure}[h]
    \centering
    \begin{tikzpicture}
      \pgfplotsset{
        width=0.8\textwidth,
        height=0.25\textwidth,
        set layers,
      }
      \begin{axis}[
        scale only axis,
        xmin = 0, xmax = 17,
        xlabel = 进程数量,
        ylabel = 耗时（s）,
        axis y line*= left,
      ]
        \addplot+[smooth]
         coordinates
        {
          (1,17.1) (2,9.2) (4,7.2)
          (8,6.1) (16,5.1)
        };
        \label{plot:base_time}
        % \addlegendentry{耗时}
      \end{axis}

      \begin{axis}[
        scale only axis,
        ymin = 0.5, ymax = 5,
        xmin = 0, xmax = 17,
        axis y line* = right,
        ylabel = 加速比
      ]
        \addlegendimage{/pgfplots/refstyle=plot:base_time}\addlegendentry{耗时}
        \addplot+[
          smooth,
          color=red
        ]
        coordinates
        {
          (1,1) (2,1.8) (4,2.1)
          (8,2.5) (16,3.4)
        };
        \addlegendentry{加速比}
      \end{axis}
    \end{tikzpicture}
    \label{fig:baseline}
    \caption{基准代码在不同线程下的运行时间和加速比}
  
  \end{figure}

  \section{性能优化}
  \subsection{性能优化：去除偶数}
  我们使用对基线代码重构并在不同的地方对偶数进行过滤，主要有以下四处修改：
  \begin{enumerate}[itemindent=1em]
    \item 在确定作为筛的素数时，直接从 3 开始，从而跳过偶数；
    \item 在对素数的倍数进行标记时，直接跳过偶数；
    \item 在寻找下一个素数筛时，仅对奇数位标志进行检验；
    \item 在统计素数个数时，同样地只对奇数进行计算。
  \end{enumerate}

  核心代码如下所示，完整代码可查阅附录。

  \begin{file}[no\_even.cpp]
    \begin{lstlisting}[language=C++]
// ...
bool *marked = new bool[proc_array_size](); // 标记数组

// 1. 直接从 3 开始进行计算，从而跳过偶数判定
for (long prime = 3; prime * prime <= n;)
{
  // 确定本线程的开始素数
  long first = (low_range / prime) * prime;
  for (int x = first; x < high_range; x += prime)
  {
    // 跳过没有在范围内的数字，以及素数本身
    if (x < low_range || x == prime || x % 2 == 0)
      continue; // 2. 跳过偶数，40% 左右的性能提升
    marked[x - low_range] = 1;
  }

  if (!pid)
  {
    do {
      prime += 1 + (prime % 2); // 3. 寻找素数时跳过偶数
    } while (prime < high_range && marked[prime]);
  }

  // 广播找到的下一个素数
  MPI_Bcast(&prime, 1, MPI_INT, 0, MPI_COMM_WORLD);
}

// 保证从 3 开始计数
for (int i = low_range; i < high_range; i += 1 + (i % 2))
{
  if (i < 3) continue;
  // 4. 统计数字时同样跳过偶数
  count += !marked[i - low_range] && (i % 2);
}
// ...
    \end{lstlisting}
  \end{file}
  性能分析：TODO

  \subsection{性能优化：消除广播}
  在偶数优化后的代码基础上，我们在每个线程内预先地计算前 $\sqrt{n}$ 个素数，然后再对每个区间端进行筛选，从而免去了素数广播耗时，预计算部分为：
  \begin{file}[baseline.cpp]
    \begin{lstlisting}[language=C++]
// ...
// 计算前 sqrt(n) 个素数
int sqrtn = (int)sqrtl(n) + 1;
bool *sqn_mark = new bool[sqrtn]();
for (int prime = 2; prime * prime < sqrtn; prime += 1) {
  if (marked[prime]) continue;
  for (int i = 2; i * prime < sqrtn; i += 1) {
    sqn_mark[i * prime] = 1;
  }
}
// ...
    \end{lstlisting}
  \end{file}
  然后在寻找下一个素数时，只需要在 \verb|sqn_mark| 数组中寻找即可：
  \begin{file}[baseline.cpp]
    \begin{lstlisting}[language=C++]
// 找到下一个素数
do {
  prime += 1 + (prime % 2); // 寻找素数时跳过偶数
} while (prime < high_range && sqn_mark[prime]);
    \end{lstlisting}
  \end{file}
  性能分析：TODO
  \subsection{性能优化：Cache 访存}

  \appendix
  \section{附录：修复 Bug 后的基准代码}
  \section{附录：重构基准代码}
  \section{附录：偶数优化}
  \section{附录：消除广播}
  \section{附录：优化 Cache}
\end{document}